generator kysely {
  provider            = "pnpx prisma-kysely"
  output              = ".."
  fileName            = "types.ts"
  // Optionally generate runtime enums to a separate file
  enumFileName        = "enums.ts"
  booleanTypeOverride = "boolean"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Test {
  id   String @id @default(cuid())
  name String
}

model Session {
  id            String   @id
  session_token String   @unique
  userId        String
  expires       DateTime @db.Timestamp()
  created       DateTime @db.Timestamp() // Clerk Webhook Event
  ended         DateTime @db.Timestamp() // Clerk webhook event
  revoked       DateTime @db.Timestamp() // Clerk Webhook Event
  removed       DateTime @db.Timestamp() // Clerk Webhook Event
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Main user table
model User {
  id                String            @id @db.VarChar(256) // id we gave users, we generated by ourselves
  clerkUserId       String?           @unique // user id from Clerk
  firstName         String?
  lastName          String?
  provider          String // Discord, Google, Facebook, etc
  providerAccountId String            @unique
  email             String?           @unique
  avatar            String?
  deleted           Boolean           @db.TinyInt // Clerk webhook event
  createdAt         DateTime          @default(now()) // Clerk webhook event "email.created"
  updatedAt         DateTime          @db.Timestamp() // Clerk webhook event
  lastLogin         DateTime?         @db.Timestamp() // last login time come from Clerk.dev
  // Relations
  organisation      UserOrganisation?
  createdProject    Project?
  project           UserInProjects?

  receivedKudos    Kudo?                 @relation("receivedKudos")
  givenKudos       Kudo?                 @relation("givenKudos")
  session          Session[]
  response         Response?
  discordAccount   DiscordAccount        @relation(fields: [discordId], references: [discordUserId])
  discordId        String                @unique
  userSubscription UserOrgSubscription[]

  @@unique([id])
}

// if users are already in discord, they might not register through us via clerk yet
// but if users registed on the website, they almost certain need to have discord account link to clerk account
model DiscordAccount {
  id               String            @id @unique @db.VarChar(256)
  clerkUserId      String?
  username         String
  discriminator    String?
  globalName       String?
  avatar           String?
  bot              Boolean?
  system           Boolean?
  mfa_enabled      Boolean?
  banner           String?
  accentColor      Int?
  locale           String?
  verified         Boolean?
  email            String?
  flags            Int?
  premiumType      Int?
  publicFlags      Int?
  refreshToken     String?
  user             User?
  project          UserInProjects[]
  server           Server[]
  discordUserId    String            @unique
  userInProjectId  String?           @db.VarChar(256)
  UserOrganisation UserOrganisation?

  @@index([clerkUserId])
  @@index([discordUserId])
  @@index([userInProjectId])
  @@index([id])
}

model Kudo {
  id          String       @id @db.VarChar(256)
  category    KudoCategory
  description String?      @db.VarChar(255)
  points      Int?         @default(1)
  responseId  String
  response    Response     @relation(fields: [responseId], references: [id])
  receiver    User         @relation("receivedKudos", fields: [receiverId], references: [clerkUserId])
  receiverId  String       @unique @db.VarChar(255)
  // Each Kudo
  giver       User         @relation("givenKudos", fields: [giverId], references: [clerkUserId])
  giverId     String       @unique @db.VarChar(255)
  multiplier  Int?         @default(1) // if someone hit emoji it will get multiplied
  createdAt   DateTime     @default(now())

  @@index(receiverId)
  @@index(responseId)
  @@index(giverId)
}

enum KudoCategory {
  TEAMWORK
  LEADERSHIP
  INNOVATION
  COMMUNITY
  OWNERSHIP
  BUILD
  QUALITY
  RESPECT
  INTEGRITY
  COMMUNICATION
  GROWTH
  FUN
}

model Server {
  // Discord Data
  id              String  @id @unique @db.VarChar(256) // Cuid can sort by creation + time bound
  discordServerId String  @unique
  name            String  @db.VarChar(100)
  icon            String? @db.VarChar(250)
  description     String?

  kickedTime DateTime? @db.Timestamp()
  vanityUrl  String?   @unique

  channels         Channel[] // Keep this because we need to run a query to get all channels in a server, also need to remember which channel we are sending message to
  DiscordAccount   DiscordAccount? @relation(fields: [discordAccountId], references: [id])
  discordAccountId String?         @db.VarChar(256)

  @@index([discordAccountId])
}

model Channel {
  id          String @id @db.VarChar(256)
  channelId   String @unique // come from discord
  channelLink String @unique // come from discord

  name      String   @db.VarChar(256)
  serverId  String
  server    Server   @relation(fields: [serverId], references: [discordServerId])
  createdAt DateTime @default(now())
  updatedAt DateTime @db.Timestamp()

  projectSettingId String           @unique @db.VarChar(256)
  ProjectSettings  ProjectSettings?

  @@unique([channelId, serverId])
  @@index([channelId])
  @@index([serverId])
  @@index([projectSettingId])
}

model Organisation {
  id               String                @id @unique @db.VarChar(256)
  clerkOrgId       String                @unique
  name             String                @db.VarChar(255)
  description      String?               @db.VarChar(255)
  deleted          Boolean               @db.TinyInt // Clerk Webhook "organization.delete"
  createdAt        DateTime              @default(now()) // Clerk Webhook "organization.created"
  updatedAt        DateTime              @updatedAt @db.Timestamp() // Clerk Webhook "organization.updated"
  user             UserOrganisation[]
  project          Project?
  userSubscription UserOrgSubscription[]
  projectSetting   ProjectSettings?
}

model UserOrganisation {
  id            String          @id @unique @db.VarChar(256)
  clerkUserId   String          @unique
  discordUserId String          @unique
  clerkOrgId    String
  user          User            @relation(fields: [clerkUserId], references: [clerkUserId])
  discordUser   DiscordAccount? @relation(fields: [discordUserId], references: [discordUserId])
  organisation  Organisation    @relation(fields: [clerkOrgId], references: [clerkOrgId])
  clerkRole     ClerkRole
  createdAt     DateTime        @default(now()) // Clerk WebhookHook "organizationMembership.created"
  deletedAt     DateTime?       @db.Timestamp() // Clerk Webhook "organizationMembership.deleted"
  updatedAt     DateTime        @updatedAt @db.Timestamp()
  project       Project?
  projectId     String?         @db.VarChar(256)

  @@index([clerkUserId])
  @@index([clerkOrgId])
  @@index([projectId])
}

enum UserRole {
  USER // equivalent to basic_member
  ADMIN // Own the organisation but not managing payment
  OWNER // A project can have two owners, owner manage payment
}

enum ProjectTier {
  FREE
  BASIC
  PRO
}

model Project {
  id               String           @id @unique @db.VarChar(256) // prefix_ + cuid2() (24)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt @db.Timestamp()
  deleted          Boolean          @db.TinyInt
  active           Boolean
  creatorId        String           @unique
  creator          User             @relation(fields: [creatorId], references: [clerkUserId])
  projectsettings  ProjectSettings?
  projectSettingId String           @unique
  name             String
  tier             ProjectTier

  organisation       Organisation?     @relation(fields: [clerkOrgId], references: [clerkOrgId])
  clerkOrgId         String?           @unique @db.VarChar(256)
  userOrganisation   UserOrganisation? @relation(fields: [userOrganisationId], references: [id])
  userOrganisationId String?           @unique @db.VarChar(256)

  @@index([id])
  @@index([creatorId])
  @@index([projectSettingId])
  @@index([clerkOrgId])
  @@index([userOrganisationId])
}

enum SubscriptionPlan {
  FREE
  STANDARD
  PRO
}

// Explain the roles in here
model UserInProjects {
  id               String  @id @unique @db.VarChar(256)
  clerkUserId      String? @unique
  discordUserId    String  @unique
  projectSettingId String
  xp               Int     @default(0)

  discordUser    DiscordAccount? @relation(fields: [discordUserId], references: [discordUserId])
  userRole       UserRole
  project        ProjectSettings @relation(fields: [projectSettingId], references: [id])
  timezone       String
  timezoneOffset Int             @db.TinyInt
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  user           User?           @relation(fields: [clerkUserId], references: [id])

  @@index([clerkUserId])
  @@index([projectSettingId])
  @@index([discordUserId])
}

// Manage explicit many to many relationship between organisation, question set up, project and users
model ProjectSettings {
  id           String           @id @unique @db.VarChar(256) // prefix_ + cuid2() (24)
  cronSchedule String           @db.VarChar(255)
  projectId    String           @unique
  project      Project          @relation(fields: [projectId], references: [id])
  organisation Organisation?    @relation(fields: [clerkOrgId], references: [clerkOrgId])
  clerkOrgId   String?          @unique @db.VarChar(256)
  participant  UserInProjects[]

  channelId String      @unique
  channel   Channel     @relation(fields: [channelId], references: [channelId])
  question  Questions[]

  sendMeme            Boolean
  greetings           String? @db.Text
  timezone            String
  followLocalTimeZone Boolean
  weekdays            String  @db.VarChar(125)

  @@index([id])
  @@index([clerkOrgId])
  @@index([projectId])
}

model Questions {
  id String @id @unique @db.VarChar(256)

  question         String          @db.Text
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  projectSettingId String
  responseId       String?
  response         Response[]
  projectSettings  ProjectSettings @relation(fields: [projectSettingId], references: [id])

  @@index([projectSettingId])
}

model Response {
  id String @id @db.VarChar(256)

  clerkUserId String    @unique
  questionId  String
  question    Questions @relation(fields: [questionId], references: [id])
  responseId  String // Discord Message ID
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [clerkUserId], references: [clerkUserId])
  kudo        Kudo[]

  @@index([clerkUserId])
  @@index([questionId])
}

model UserOrgSubscription {
  id             String           @id @unique @db.VarChar(256) // prefix_ + cuid2() (24)
  discordUserId  String
  stripeId       String           @unique
  subscriptionId String           @unique
  clerkUserId    String           @unique
  clerkOrgId     String?          @unique
  subscribedAt   DateTime         @db.Timestamp()
  paidUntil      DateTime         @db.Timestamp()
  expiresAt      DateTime         @db.Timestamp()
  plan           SubscriptionPlan
  user           User             @relation(fields: [clerkUserId], references: [clerkUserId])
  organisation   Organisation?    @relation(fields: [clerkOrgId], references: [clerkOrgId])

  @@index([discordUserId])
}

enum ClerkRole {
  basic_member
  admin
}

enum Timezone {
  LOCAL
  UTC
  GMT
  EST
  EDT
  CST
  CDT
  MST
  MDT
  PST
  PDT
  IST
  BST
  CET
  CEST
  AEDT
  AEST
  ACST
  AWST
  NZST
  NZDT
  JST
  KST
  WAT
  CAT
  EAT
  SAST
  AST
  ADT
  NST
  NDT
  IRST
  MSK
  FET
  EET
  WET
  CVT
  WGST
  WGT
  ART
  CLT
  CLST
  AKST
  AKDT
  HAST
  HADT
  ChST
  WST
  LINT
  CHADT
  CHAST
  TOK
  GST
  VET
  BOT
  COT
  PET
  PYT
  PYST
  BRST
  BRT
  UYT
  GFT
}
